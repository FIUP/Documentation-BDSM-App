% =================================================================================================
% File:			visione_generale_della_strategia_di_verifica.tex
% Description:	Definisce la sezione relativa alla sezione della strategia
% Created:		2014/12/16
% Author:		Ceccon Lorenzo / Faccin Nicola
% Email:		ceccon.lorenzo@mashup.unipd.it / faccin.nicola@mashup.unipd.it
% =================================================================================================
% Modification History:
% Version		Modifier Date		Change											Author
% 0.0.1 		2014/12/05 			iniziata stesura documento sezione				Lorenzo C./Nicola F.
% =================================================================================================
% Version		Modifier Date 		Change											Author
% 1.0.1			2015/02/15			correzioni secondo valutazione					Faccin Nicola

% CONTENUTO DEL CAPITOLO

\section{Visione generale della strategia di verifica}
		\label{sub:visione_generale_della_strategia_di_verifica}

	\subsection{Definizione degli obiettivi di qualità}
		\label{sub:definizione_degli_obbiettivi_di_qualità}
		\subsubsection{Qualità di processo}
		Per garantire la qualità di prodotto è necessario, prima di tutto, ottenere la qualità dei processi che lo compongono. Per ottenere la qualità di processo si è quindi deciso di fare riferimento allo standard ISO/IEC 15504, noto anche come SPICE che fornisce degli strumenti per valutare i processi, assegnando a ciascuno di essi un grado di maturità definito dal modello CMM che lo standard incorpora.\\
		Per ottenere un miglioramento di questi processi, si farà affidamento al ciclo di Deming, noto anche come PDCA, che definisce un metodo di gestione iterativo per il controllo e il miglioramento continuo dei processi.
		
		\subsubsection{Qualità di prodotto}
		Per ottenere la qualità di prodotto è necessario fissare degli obiettivi qualitativi al fine di massimizzare l'efficacia. A tale scopo, lo standard ISO/IEC 9126 definisce un modello di qualità software e le metriche per il raggiungimento di tali obiettivi. 
		
	\subsection{Procedure di controllo di qualità di processo}
		\label{sub:procedure_di_controllo_di_qualità_di_processo}
	Per garantire la qualità di processo sarà applicato il principio del PDCA ad ognuno dei processi. In questo modo si potrà ottenere un miglioramento continuo dei processi e quindi, di conseguenza, il miglioramento del prodotto.\\
	Per ottenere la qualità è necessario attuare le seguenti procedure di controllo:
		\begin{itemize}
			\item la pianificazione deve essere dettagliata;
			\item le risorse necessarie devono essere definite in modo chiaro;
			\item le attività pianificate devono essere monitorate.
		\end{itemize}
	Una descrizione più dettagliata di tali attività viene riportata nel \docNameVersionPdP.\\
	Mediante l'analisi costante della qualità di prodotto si ottengono informazioni anche sulla qualità dei processi. Un prodotto di bassa qualità indica la presenza di qualche processo migliorabile.
	
	\subsection{Procedure di controllo di qualità di prodotto}
	Per garantire la qualità del prodotto software si fa affidamento a due modalità di controllo:
		\begin{itemize}
			\item \textbf{Software Quality Assurance (SQA):} è un insieme di attività che assicurano che il software sviluppato sia conforme alle specifiche di qualità standard o definite dal gruppo. L'SQA è un processo appartenente al ciclo di vita del software che controlla regolarmente e preventivamente il software sviluppato per assicurare il rispetto degli obbiettivi di qualità prefissati;
			\item \textbf{Verifica e Validazione (V\&V):} sono due processi che controllano che il sistema software soddisfi le specifiche e che raggiunga appieno il suo scopo.\\
			Per verifica si intende il processo attuo a valutare che il software in una determinata fase di sviluppo soddisfi le condizioni imposte all'inizio di tale fase. Per validazione si intende il processo attuo a valutare se al termine del processo di sviluppo questo soddisfi i requisiti specificati. In altre parole, la verifica garantisce che il software è stato creato correttamente, mentre la validazione assicura che si è creato il giusto prodotto.
		\end{itemize}
	
	\subsection{Organizzazione}
	L'attività di verifica accompagnerà l'intero ciclo di vita del software e sarà effettuata su tutti i processi realizzati e sugli output prodotti da questi ultimi. La verifica sarà applicata solamente ai cambiamenti effettuati dall'ultima versione approvata del prodotto.\\
	Il team ha scelto di adottare un modello di ciclo di vita di tipo incrementale suddiviso in diverse fasi e riportate dettagliatamente nel \docNameVersionPdP. Per ciascuna di queste fasi verranno utilizzate specifiche attività di verifica.\\ Il processo di verifica sarà così composto:
	\begin{itemize}
		\item \textbf{Ricerca e implementazione degli strumenti:}  in questa fase l'attività di verifica consente di verificare che tutti gli script creati siano corretti e che l'output prodotto dagli stessi sia uguale alle aspettative;
		\item \textbf{Analisi dei requisiti e di dettaglio:} in questa fase si verificherà che ogni requisito abbia corrispondenza in un caso d'uso e si effettueranno dei test sulla documentazione prodotta per verificare che rispetti le \docNameVersionNdP;
		\item \textbf{Progettazione architetturale:} l'attività di verifica in questa fase consiste nell'analizzare che la soluzione generale ad alto livello soddisfi i requisiti richiesti oltre a verificare i processi utilizzati per ottenere questa soluzione;
		\item \textbf{Progettazione di dettaglio e codifica dei requisiti obbligatori, desiderabili e opzionali:} si eseguiranno attività di verifica sui processi di progettazione e codifica del codice prodotto dai programmatori facendo uso di tecniche di analisi statica e dinamica;
		\item \textbf{Validazione:} in quest'ultima fase verrà effettuato il collaudo del prodotto che garantirà il corretto funzionamento del prodotto realizzato.
	\end{itemize}
	
	\subsection{Pianificazione strategica e temporale}
	L'attività di verifica necessaria, per il miglioramento della qualità dei processi e del prodotto, deve essere sistematica ed organizzata. Ciò permetterà l'individuazione e la correzione degli errori il prima possibile evitando la propagazione di questi ultimi in larga scala.\\
	Ciascuna attività che riguarda la documentazione o la codifica dovrà essere preceduta da uno studio preliminare che ci permetta di rendere chiaro la struttura degli stessi. Questo studio preventivo ci consentirà di ottenere un maggiore livello di qualità e una minore possibilità di fallimento. \\
	Per quanto riguarda le tempistiche, l'obbiettivo primario è quello di rispettare le scadenze forniteci del committente e riportate nel \docNameVersionPdP.
	
	\subsection{Responsabilità}
	Le responsabilità relative all'assegnazione degli incarichi appartengono al \roleProjectManager, mentre le responsabilità relative all'adeguamento dell'ambiente di lavoro per lo svolgimento di tutti i compiti necessari alla realizzazione del progetto appartengono all'\roleAdministrator.

	\subsection{Risorse necessarie}
	Le risorse necessarie alla verifica della qualità dei processi e del prodotto sono:
		\begin{itemize}
  			\item \textbf{Risorse umane:} \textnormal{il \roleProjectManager{} controlla la qualità dei processi interni, l'\roleAdministrator{} definisce le norme e i piani per le attività di verifica, il \roleProgrammer{} esegue le prove di verifica e validazione del codice, il \roleVerifier{} esegue la verifica dei documenti e fornisce i risultati delle prove effettuate. Per una descrizione più dettagliata dei ruoli consultare il \docNameVersionPdP;}
  			\item \textbf{Risorse software:} \textnormal{sono necessari strumenti per il tracciamento dei requisiti, per la stesura dei documenti in \LaTeX, per la creazione di diagrammi UML, per lo sviluppo del prodotto e per il supporto e la verifica del codice;}
  			\item \textbf{Risorse hardware:} \textnormal{sono necessari computer per scrivere documenti e creare il prodotto software finale. \`E richiesto un ambiente di lavoro stabile in cui poter lavorare al progetto.}
		\end{itemize}

	\subsection{Misure e metriche}
		\label{sub:misure_e_metriche}
	Il processo di verifica, per essere utile ed informativo, deve esse quantificabile. Vanno
quindi stabilite a priori delle metriche. Sulla base di queste, saranno basate le misure
rilevate dal processo di verifica. Nel caso in cui vi fossero metriche approssimate ed incerte,
esse miglioreranno in modo incrementale. Questo è permesso grazie al ciclo di vita adottato
descritto nel \docNameVersionPdP. Vi possono essere due tipologie di range:
\begin{itemize}
	\item \textbf{range di accettazione:} termini entro i quali il prodotto è accettato
	\item \textbf{range ottimale:} termini entro i quali il prodotto dovrebbe collocarsi, questi non sono vincolanti, ma caldamente consigliati, il mancato rispetto di tali limiti deve seguire una verifica approfondita. 
\end{itemize}
	\subsubsection{Metriche per i processi}
		\begin{itemize}
		
			\item \textbf{Schedule Variance:} questo indice di efficacia mette in relazione il lavoro pianificato con quello realmente svolto. Se il confronto è maggiore di zero, allora si è svolto più lavoro rispetto a quello pianificato, viceversa se negativo. L'utilizzo di periodi di slack aumenta la possibilità che la schedule variance assumi valori positivi.
			\begin{itemize}
				\item \textbf{range di accettazione:} $\geq$ - (preventivo fase *5\%);
				\item \textbf{range ottimale:} $\geq$ 0.
			\end{itemize}
			\item \textbf{Budget Variance:} l'avanzamento dei processi verrà valutato anche tramite la budget variance. Questo indice di efficienza mette in relazione il preventivo pianificato con il consuntivo. Se tale indice è maggiore di zero, allora si è riusciti ad essere più efficienti di quello pianificato, viceversa se negativo.
			\begin{itemize}
				\item \textbf{range di accettazione:} $\geq$ - (preventivo fase*10\%);
				\item \textbf{range ottimale:} $\geq$ 0.
			\end{itemize}
		\end{itemize}

		\subsubsection{Metriche per i documenti}
		\textbf{Indice Gulpease:} questo indice, tarato specificatamente per la lingua italiana, ha anche il vantaggio di utilizzare la lunghezza delle parole in lettere e non delle sillabe, semplificandone il calcolo.
			\begin{center}
				\begin{math}
					89+\frac{300 * (Numero\ delle\ frasi) - 10 * (Numero\ delle\ lettere)}{Numero\ delle\ parole}
				\end{math}
			\end{center}
		100 indica la leggibilità più alta mentre 0 quella più bassa, sono presenti dei range così da poter quantificare meglio la complessità del documento in analisi:
			\begin{itemize}
				\item inferiori a 80 sono difficili da leggere per chi ha la licenza elementare;
				\item inferiori a 60 sono difficili da leggere per che ha la licenza media;
				\item inferiori a 40 difficili da leggere per chi possiede un diploma superiore;
			\end{itemize}
			\begin{itemize}
					\item \textbf{range di accettazione:} [40 - 100];
					\item \textbf{range ottimale:} [50 - 100].
			\end{itemize}

È stato considerato che questo indice tuttavia non indica se il testo sia comprensibile o meno, infatti contenuto delle frasi potrebbe essere totalmente non comprensibile e/o stravolto, ma
avere lo stesso un ottimo indice Gulpease. Visto lo scopo dei documenti e e la loro natura di documenti formali, capiterà spesso che vengano impiegati termini tecnici che non si possono sostituire, interrompere la frase a favore di un indice più alto potrebbe spezzarne il ragionamento o, storpiarne il contenuto e usare frasi troppo dirette potrebbe risultare poco professionale ai fini del documento. Perciò, i documenti saranno valutati precedentemente da un essere umano per stabilire se e come il testo potrebbe essere semplificato. I limiti imposti da tale indice saranno sufficientemente rilassati per accettare frasi un po' più articolate.
		\subsubsection{Metriche per il software}
			\begin{itemize}
				\item \textbf{Complessità Ciclomatica:} è utilizzata per misurare la complessità di un metodo, attraverso il grafo di controllo di flusso che misura direttamente il numero di cammini linearmente indipendenti. I nodi di questo grafo rappresentano gruppi indivisibili di istruzioni e gli archi connettono due nodi solamente se le istruzioni di un nodo possono essere eseguite immediatamente dopo le istruzioni dell'altro nodo.\\
				In questo progetto si cercherà di rispettare la raccomandazione di \textit{McCabe}, che sviluppò tale teoria, ossia quella di non superare una complessità di 10. Rispettando questo vincolo si aumentano le possibilità di riuso del codice, manutenibilità, coesione e correttezza di quest'ultimo. Il vincolo presentato sarà di tipo lasco, ossia potrà essere portato a valori maggiori nell'eventualità porti a notevoli benefici in termini di velocità di esecuzione.
				\begin{itemize}
					\item \textbf{range di accettazione:} <15;
					\item \textbf{range ottimale:} <10.
				\end{itemize}				
				\item \textbf{Numero di metodi:} metrica utilizzata per calcolare una media delle occorrenze dei metodi per package; valori alti potrebbero indicare la necessità di scomporlo. 	
				\begin{itemize}
					\item \textbf{range di accettazione:} [3 - 10];
					\item \textbf{range ottimale:} [3 - 8].
				\end{itemize}
				
				\item \textbf{Numero di parametri:} metrica utilizzata per calcolare il numero di parametri formali di un metodo. Un valore basso e indice di maggior manutenibilità e astrazione del codice.
				\begin{itemize}
					\item \textbf{range di accettazione:} [0 - 8];
					\item \textbf{range ottimale:} [0 - 4].
				\end{itemize}
				\item \textbf{Linee di codice per linee di commento:} metrica atta a migliorare la manutenibilità del codice attraverso il monitoraggio del rapporto tra questi valori.
				\begin{itemize}
					\item \textbf{range di accettazione:} >0.20;
					\item \textbf{range ottimale:} >0.35.
				\end{itemize}				
				
				\item \textbf{Numero di bug per linee di codice:} metrica per la misura dei bug trovati per un certo quantitativo di linee di codice. Questa metrica è utile in quanto all'aumentare dell'ampiezza del codice si aumenta la probabilità di nascondere degli errori. Presupponendo che nessuno del gruppo avrà conoscenze sufficienti dello stack tecnologico che si andrà ad utilizzare si partirà con un valore di accettazione alto per poi cercare di ridurlo in modo incrementale. L'obbiettivo fissato è quello di raggiungere valori compresi tra 0 e 20. Difficoltà particolari verranno gestite dal responsabile di progetto;
				\item \textbf{Numero di livelli di annidamento:} metrica per misurare il livello di annidamento dei metodi. Un numero elevato comporta eccessiva complessità del codice e ne riduce il livello di astrazione.
				\begin{itemize}
					\item \textbf{range di accettazione:} [1 - 6];
					\item \textbf{range ottimale:} [1 - 4].
				\end{itemize}
				
				\item \textbf{Grado di accoppiamento:} viene derivato da due singoli indici:
				\begin{itemize}
					\item \textbf{Accoppiamento afferente:} questo indice viene calcolato dal numero di classi esterne al package che hanno dipendenze con classi interne. Se il numero è basso significa che il package fornirà poche funzionalità, se è molto alto avremo molte dipendenze da tracciare in caso di modifiche.
					\item \textbf{Accoppiamento efferente:} questo indice calcolato dal numero di classi interne al package che hanno dipendenze con classi esterne ad esso. Un numero alto può significare una scarsa progettazione.
				\end{itemize}
				
				\item \textbf{Grado di instabilità:} metrica per la misura dell'instabilità delle componenti del sistema. Questa e molto legata all'indice di accoppiamento afferente e quello efferente, in quanto viene calcolato con questa formula:\\
				\begin{center}
					\begin{math}
						I=\frac{Ce}{Ca+Ce}
					\end{math}
				\end{center}		
				dove Ce rappresenta l'accoppiamento efferente e Ca quello afferente.
				\begin{itemize}
					\item \textbf{range di accettazione:} [0 - 0.8];
					\item \textbf{range ottimale:} [0.3 - 0.7].
				\end{itemize}
				
				\item \textbf{Logical SLOC:} misura le dimensioni del software basandosi sul numero di linee di codice sorgente. Ci sono due tipi di SLOC, quello \textit{physical} e quello \textit{logical} : si userà il secondo, che conta solamente gli statement, ignorando le righe vuote, quelle bianche e i commenti.
				\begin{itemize}
					\item \textbf{range di accettazione:} [1 - 80]; 
					\item \textbf{range ottimale:} [1 - 50]
				\end{itemize}
								
				\item \textbf{Copertura del codice:} metrica che misura la copertura dei test. Maggiore sarà questo valore più significativi saranno i test eseguiti. Questa metrica può essere raffinata tralasciando nell'analisi i metodi semplici che non richiedono test. La copertura del codice può essere di due tipologie:
				\begin{itemize}
					\item \textbf{Statement coverage:}\\
					\begin{center}
						\begin{math}
							\frac{number\ of\ statements\ exercised} {total\ number\ of\ statements} * 100
						\end{math}
					\end{center}
					Questo rappresenta il valore in percentuale del numero di linee di codice esaminate dai test.
					\begin{itemize}
						\item \textbf{range di accettazione:} [80\% - 100\%];
						\item \textbf{range ottimale:} [90\% - 100\%].
					\end{itemize}
					\item \textbf{Branch coverage:}\\
					\begin{center}
						\begin{math}
							\frac{number\ of\ decision\ outcomes\ exercised}{total\ number\ of\ decision\ outcomes} * 100
						\end{math}
					\end{center}
					Verifica che ciascun ramo della logica del flusso di controllo sia eseguito.
					\begin{itemize}
						\item \textbf{range di accettazione:} [80\% - 100\%];
						\item \textbf{range ottimale:} [90\% - 100\%].
					\end{itemize}		
				\end{itemize}					
				
				\item \textbf{Validazione W3C:} l'applicativo web deve superare correttamente i test di validazione offerti dal W3C. Qui si controlla il numero di avvisi o inesattezze per pagina che il test segnala.
				\begin{itemize}
					\item \textbf{range di accettazione:} [0 - 10];
					\item \textbf{range ottimale:} [0].
				\end{itemize}				
				
			\end{itemize}
			

	\pagebreak
